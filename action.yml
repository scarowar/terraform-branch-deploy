name: terraform-branch-deploy
description: ChatOps for Terraform deployments via GitHub PRs - enterprise-grade integration with branch-deploy

author: Sourab Kanthavar <@scarowar>

branding:
  icon: git-pull-request
  color: purple

inputs:
  # === MODE SELECTION ===
  mode:
    description: |
      trigger = Parse command via branch-deploy, export TF_BD_* to GITHUB_ENV, STOP
      execute = Run terraform with lifecycle completion (reads TF_BD_* from GITHUB_ENV)
      
      Use both modes as CONDITIONAL STEPS in a SINGLE JOB:
      - Trigger mode exports env vars
      - Custom steps (credentials) can access env vars  
      - Execute mode picks up env vars automatically
    required: true

  # === REQUIRED ===
  github-token:
    description: "GitHub token with pull-requests:write, deployments:write, contents:write"
    required: true

  # === TF-BRANCH-DEPLOY SPECIFIC ===
  config-path:
    description: "Path to .tf-branch-deploy.yml"
    default: ".tf-branch-deploy.yml"
  terraform-version:
    description: "Terraform version to install"
    default: "latest"
  dry-run:
    description: "Print commands without running"
    default: "false"

  # === BRANCH-DEPLOY PASSTHROUGH (trigger mode only) ===
  trigger:
    description: "Deploy command trigger"
    default: ".apply"
  noop-trigger:
    description: "Plan command trigger"
    default: ".plan"
  lock-trigger:
    description: "Lock command trigger"
    default: ".lock"
  unlock-trigger:
    description: "Unlock command trigger"
    default: ".unlock"
  help-trigger:
    description: "Help command trigger"
    default: ".help"
  lock-info-alias:
    description: "Lock info alias"
    default: ".wcid"
  param-separator:
    description: "Parameter separator in commands"
    default: "|"
  environment-targets:
    description: "Comma-separated environments (auto-detected from config if empty)"
    default: ""
  production-environments:
    description: "Comma-separated production environments"
    default: ""
  environment-urls:
    description: "Environment URLs mapping"
    default: ""
  draft-permitted-targets:
    description: "Environments allowing draft PR deployments"
    default: ""
  stable-branch:
    description: "Stable branch for rollbacks"
    default: "main"
  update-branch:
    description: "How to handle outdated branches: disabled|warn|force"
    default: "warn"
  outdated-mode:
    description: "How to handle outdated branches"
    default: "strict"
  allow-sha-deployments:
    description: "Allow deployments by SHA"
    default: "false"
  enforced-deployment-order:
    description: "Required deployment order"
    default: ""
  checks:
    description: "Which checks must pass before deployment"
    default: "all"
  ignored-checks:
    description: "Checks to ignore"
    default: ""
  skip-ci:
    description: "CI pattern to skip"
    default: ""
  skip-reviews:
    description: "Skip PR review requirement"
    default: ""
  required-contexts:
    description: "Required status contexts"
    default: ""
  permissions:
    description: "Required permissions"
    default: "write,admin"
  admins:
    description: "Admin users/teams"
    default: "false"
  admins-pat:
    description: "Admin PAT for checks"
    default: "false"
  commit-verification:
    description: "Require verified commits"
    default: "false"
  disable-naked-commands:
    description: "Require 'to <env>' in commands"
    default: "false"
  allow-forks:
    description: "Allow fork deployments"
    default: "true"
  allow-non-default-target-branch:
    description: "Allow non-default target branches"
    default: "false"
  deployment-confirmation:
    description: "Require deployment confirmation"
    default: "false"
  deployment-confirmation-timeout:
    description: "Confirmation timeout seconds"
    default: "300"
  global-lock-flag:
    description: "Global lock flag"
    default: "--global"
  sticky-locks:
    description: "Keep locks after deployment"
    default: "false"
  sticky-locks-for-noop:
    description: "Keep locks for noop"
    default: "false"
  successful-deploy-labels:
    description: "Labels for successful deploy"
    default: ""
  successful-noop-labels:
    description: "Labels for successful noop"
    default: ""
  failed-deploy-labels:
    description: "Labels for failed deploy"
    default: ""
  failed-noop-labels:
    description: "Labels for failed noop"
    default: ""
  skip-successful-noop-labels-if-approved:
    description: "Skip noop labels if approved"
    default: "false"
  skip-successful-deploy-labels-if-approved:
    description: "Skip deploy labels if approved"
    default: "false"
  use-security-warnings:
    description: "Show security warnings"
    default: "true"
  merge-deploy-mode:
    description: "Merge deploy mode"
    default: "false"
  unlock-on-merge-mode:
    description: "Unlock on merge"
    default: "false"
  environment-url-in-comment:
    description: "Show env URL in comment"
    default: "true"
  deploy-message-path:
    description: "Path to deploy message file"
    default: ""
  reaction:
    description: "Initial reaction to command"
    default: "eyes"

outputs:
  # === STATE (from trigger mode) ===
  continue:
    description: "'true' if deployment should proceed"
    value: ${{ steps.branch-deploy.outputs.continue }}
  triggered:
    description: "'true' if command was detected"
    value: ${{ steps.branch-deploy.outputs.triggered }}
  environment:
    description: "Target environment"
    value: ${{ steps.branch-deploy.outputs.environment }}
  operation:
    description: "plan, apply, or rollback"
    value: ${{ steps.derive-operation.outputs.operation }}
  is-rollback:
    description: "'true' if rollback operation"
    value: ${{ steps.derive-operation.outputs.is_rollback }}
  sha:
    description: "Commit SHA to deploy"
    value: ${{ steps.branch-deploy.outputs.sha }}
  ref:
    description: "Branch ref to checkout (stable branch for rollbacks)"
    value: ${{ steps.branch-deploy.outputs.ref }}
  noop:
    description: "'true' for plan operations"
    value: ${{ steps.branch-deploy.outputs.noop }}
  actor:
    description: "User who triggered deployment"
    value: ${{ steps.branch-deploy.outputs.actor }}
  params:
    description: "Raw parameters from command"
    value: ${{ steps.branch-deploy.outputs.params }}
  comment-id:
    description: "Triggering comment ID"
    value: ${{ steps.branch-deploy.outputs.comment_id }}
  deployment-id:
    description: "GitHub deployment ID"
    value: ${{ steps.branch-deploy.outputs.deployment_id }}
  initial-reaction-id:
    description: "Initial reaction ID for cleanup"
    value: ${{ steps.branch-deploy.outputs.initial_reaction_id }}
  type:
    description: "Command type (deploy, lock, unlock, etc.)"
    value: ${{ steps.branch-deploy.outputs.type }}
  issue-number:
    description: "PR/Issue number"
    value: ${{ steps.branch-deploy.outputs.issue_number }}

  # Terraform-specific (from execute mode)
  working-directory:
    description: "Terraform working directory"
    value: ${{ steps.tf-execute.outputs.working_directory }}
  var-files:
    description: "JSON array of var files"
    value: ${{ steps.tf-execute.outputs.var_files }}
  is-production:
    description: "'true' if production environment"
    value: ${{ steps.tf-execute.outputs.is_production }}
  plan-file:
    description: "Path to plan file (after plan)"
    value: ${{ steps.tf-execute.outputs.plan_file }}
  plan-checksum:
    description: "SHA256 of plan file"
    value: ${{ steps.tf-execute.outputs.plan_checksum }}
  has-changes:
    description: "'true' if plan has changes"
    value: ${{ steps.tf-execute.outputs.has_changes }}

runs:
  using: composite
  steps:
    # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    # â•‘                              SETUP (both modes)                          â•‘
    # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - name: Verify Python Requirements
      shell: bash
      run: |
        set +e
        if ! command -v python3 &> /dev/null; then
          echo "::error::Python 3 is not installed or not in PATH"
          exit 1
        fi
        python3 - <<'EOF'
        import sys
        if sys.version_info < (3, 12):
            print("::error::tf-branch-deploy requires Python 3.12 or higher")
            sys.exit(1)
        print(f"âœ… Python {sys.version.split()[0]}")
        EOF

    - name: Setup UV
      uses: astral-sh/setup-uv@681c641aba71e4a1c380be3ab5e12ad51f415867

    - name: Install tf-branch-deploy
      shell: bash
      run: |
        uv venv "${{ runner.temp }}/tf-bd-venv"
        . "${{ runner.temp }}/tf-bd-venv/bin/activate"
        uv pip install "${{ github.action_path }}"
        echo "${{ runner.temp }}/tf-bd-venv/bin" >> $GITHUB_PATH

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ inputs.terraform-version }}
        terraform_wrapper: false

    - name: Setup tfcmt
      shell: bash
      run: |
        TFCMT_VERSION="v4.14.0"
        curl -fsSL "https://github.com/suzuki-shunsuke/tfcmt/releases/download/${TFCMT_VERSION}/tfcmt_linux_amd64.tar.gz" | tar xz -C /usr/local/bin tfcmt
        chmod +x /usr/local/bin/tfcmt

    # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    # â•‘                           TRIGGER MODE                                    â•‘
    # â•‘   Parse command â†’ Export TF_BD_* env vars â†’ STOP (no terraform)          â•‘
    # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - name: "[Trigger] Detect Environments from Config"
      id: detect-envs
      if: inputs.mode == 'trigger'
      shell: bash
      env:
        INPUT_ENVIRONMENT_TARGETS: ${{ inputs.environment-targets }}
        INPUT_PRODUCTION_ENVIRONMENTS: ${{ inputs.production-environments }}
        INPUT_CONFIG_PATH: ${{ inputs.config-path }}
      run: |
        if [ -n "$INPUT_ENVIRONMENT_TARGETS" ]; then
          echo "targets=$INPUT_ENVIRONMENT_TARGETS" >> $GITHUB_OUTPUT
          default_env=$(echo "$INPUT_ENVIRONMENT_TARGETS" | cut -d',' -f1)
          echo "default=${default_env}" >> $GITHUB_OUTPUT
          echo "production=$INPUT_PRODUCTION_ENVIRONMENTS" >> $GITHUB_OUTPUT
        else
          config_path="$INPUT_CONFIG_PATH"
          if [ -f "$config_path" ]; then
            targets=$(tf-branch-deploy environments --config "$config_path" 2>/dev/null || echo "production")
            default=$(yq -r '.["default-environment"] // "production"' "$config_path" 2>/dev/null || echo "production")
            production=$(yq -r '.["production-environments"] | join(",")' "$config_path" 2>/dev/null || echo "production")
          else
            targets="production"
            default="production"
            production="production"
          fi
          echo "targets=$targets" >> $GITHUB_OUTPUT
          echo "default=$default" >> $GITHUB_OUTPUT
          echo "production=$production" >> $GITHUB_OUTPUT
        fi

    - name: "[Trigger] IssueOps Command Dispatcher"
      id: branch-deploy
      if: inputs.mode == 'trigger'
      uses: github/branch-deploy@v11
      with:
        github_token: ${{ inputs.github-token }}
        # CRITICAL: We handle lifecycle completion in execute mode
        skip_completing: "true"
        trigger: ${{ inputs.trigger }}
        noop_trigger: ${{ inputs.noop-trigger }}
        lock_trigger: ${{ inputs.lock-trigger }}
        unlock_trigger: ${{ inputs.unlock-trigger }}
        help_trigger: ${{ inputs.help-trigger }}
        lock_info_alias: ${{ inputs.lock-info-alias }}
        param_separator: ${{ inputs.param-separator }}
        environment: ${{ steps.detect-envs.outputs.default }}
        environment_targets: ${{ steps.detect-envs.outputs.targets }}
        production_environments: ${{ steps.detect-envs.outputs.production }}
        environment_urls: ${{ inputs.environment-urls }}
        draft_permitted_targets: ${{ inputs.draft-permitted-targets }}
        stable_branch: ${{ inputs.stable-branch }}
        update_branch: ${{ inputs.update-branch }}
        outdated_mode: ${{ inputs.outdated-mode }}
        allow_sha_deployments: ${{ inputs.allow-sha-deployments }}
        enforced_deployment_order: ${{ inputs.enforced-deployment-order }}
        checks: ${{ inputs.checks }}
        ignored_checks: ${{ inputs.ignored-checks }}
        skip_ci: ${{ inputs.skip-ci }}
        skip_reviews: ${{ inputs.skip-reviews }}
        required_contexts: ${{ inputs.required-contexts }}
        permissions: ${{ inputs.permissions }}
        admins: ${{ inputs.admins }}
        admins_pat: ${{ inputs.admins-pat }}
        commit_verification: ${{ inputs.commit-verification }}
        disable_naked_commands: ${{ inputs.disable-naked-commands }}
        allow_forks: ${{ inputs.allow-forks }}
        allow_non_default_target_branch_deployments: ${{ inputs.allow-non-default-target-branch }}
        deployment_confirmation: ${{ inputs.deployment-confirmation }}
        deployment_confirmation_timeout: ${{ inputs.deployment-confirmation-timeout }}
        global_lock_flag: ${{ inputs.global-lock-flag }}
        sticky_locks: ${{ inputs.sticky-locks }}
        sticky_locks_for_noop: ${{ inputs.sticky-locks-for-noop }}
        successful_deploy_labels: ${{ inputs.successful-deploy-labels }}
        successful_noop_labels: ${{ inputs.successful-noop-labels }}
        failed_deploy_labels: ${{ inputs.failed-deploy-labels }}
        failed_noop_labels: ${{ inputs.failed-noop-labels }}
        skip_successful_noop_labels_if_approved: ${{ inputs.skip-successful-noop-labels-if-approved }}
        skip_successful_deploy_labels_if_approved: ${{ inputs.skip-successful-deploy-labels-if-approved }}
        use_security_warnings: ${{ inputs.use-security-warnings }}
        merge_deploy_mode: ${{ inputs.merge-deploy-mode }}
        unlock_on_merge_mode: ${{ inputs.unlock-on-merge-mode }}
        environment_url_in_comment: ${{ inputs.environment-url-in-comment }}
        deploy_message_path: ${{ inputs.deploy-message-path }}
        reaction: ${{ inputs.reaction }}

    - name: "[Trigger] Derive Operation and Rollback"
      id: derive-operation
      if: inputs.mode == 'trigger' && steps.branch-deploy.outputs.triggered == 'true'
      shell: bash
      env:
        BD_NOOP: ${{ steps.branch-deploy.outputs.noop }}
        BD_REF: ${{ steps.branch-deploy.outputs.ref }}
        STABLE_BRANCH: ${{ inputs.stable-branch }}
      run: |
        # Derive operation: plan, apply, or rollback
        if [[ "$BD_NOOP" == "true" ]]; then
          OPERATION="plan"
          IS_ROLLBACK="false"
        elif [[ "$BD_REF" == "$STABLE_BRANCH" ]]; then
          # Ref is stable branch = rollback (.apply main to dev)
          OPERATION="rollback"
          IS_ROLLBACK="true"
        else
          OPERATION="apply"
          IS_ROLLBACK="false"
        fi
        
        echo "operation=${OPERATION}" >> $GITHUB_OUTPUT
        echo "is_rollback=${IS_ROLLBACK}" >> $GITHUB_OUTPUT
        echo "âœ… Operation: ${OPERATION}, Is Rollback: ${IS_ROLLBACK}"

    - name: "[Trigger] Export State to GITHUB_ENV"
      if: inputs.mode == 'trigger' && steps.branch-deploy.outputs.triggered == 'true'
      shell: bash
      env:
        BD_CONTINUE: ${{ steps.branch-deploy.outputs.continue }}
        BD_ENVIRONMENT: ${{ steps.branch-deploy.outputs.environment }}
        BD_SHA: ${{ steps.branch-deploy.outputs.sha }}
        BD_REF: ${{ steps.branch-deploy.outputs.ref }}
        BD_ACTOR: ${{ steps.branch-deploy.outputs.actor }}
        BD_PARAMS: ${{ steps.branch-deploy.outputs.params }}
        BD_DEPLOYMENT_ID: ${{ steps.branch-deploy.outputs.deployment_id }}
        BD_COMMENT_ID: ${{ steps.branch-deploy.outputs.comment_id }}
        BD_INITIAL_REACTION_ID: ${{ steps.branch-deploy.outputs.initial_reaction_id }}
        BD_ISSUE_NUMBER: ${{ steps.branch-deploy.outputs.issue_number }}
        BD_NOOP: ${{ steps.branch-deploy.outputs.noop }}
        BD_TYPE: ${{ steps.branch-deploy.outputs.type }}
        DERIVED_OPERATION: ${{ steps.derive-operation.outputs.operation }}
        DERIVED_IS_ROLLBACK: ${{ steps.derive-operation.outputs.is_rollback }}
      run: |
        # Write all TF_BD_* variables to GITHUB_ENV for execute mode
        echo "TF_BD_CONTINUE=${BD_CONTINUE}" >> $GITHUB_ENV
        echo "TF_BD_ENVIRONMENT=${BD_ENVIRONMENT}" >> $GITHUB_ENV
        echo "TF_BD_OPERATION=${DERIVED_OPERATION}" >> $GITHUB_ENV
        echo "TF_BD_IS_ROLLBACK=${DERIVED_IS_ROLLBACK}" >> $GITHUB_ENV
        echo "TF_BD_SHA=${BD_SHA}" >> $GITHUB_ENV
        echo "TF_BD_REF=${BD_REF}" >> $GITHUB_ENV
        echo "TF_BD_ACTOR=${BD_ACTOR}" >> $GITHUB_ENV
        echo "TF_BD_PR_NUMBER=${BD_ISSUE_NUMBER}" >> $GITHUB_ENV
        echo "TF_BD_PARAMS=${BD_PARAMS}" >> $GITHUB_ENV
        echo "TF_BD_DEPLOYMENT_ID=${BD_DEPLOYMENT_ID}" >> $GITHUB_ENV
        echo "TF_BD_COMMENT_ID=${BD_COMMENT_ID}" >> $GITHUB_ENV
        echo "TF_BD_INITIAL_REACTION_ID=${BD_INITIAL_REACTION_ID}" >> $GITHUB_ENV
        echo "TF_BD_NOOP=${BD_NOOP}" >> $GITHUB_ENV
        echo "TF_BD_TYPE=${BD_TYPE}" >> $GITHUB_ENV
        
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "                    ðŸš€ TRIGGER MODE COMPLETE"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Environment:  ${BD_ENVIRONMENT}"
        echo "Operation:    ${DERIVED_OPERATION}"
        echo "Is Rollback:  ${DERIVED_IS_ROLLBACK}"
        echo "Ref:          ${BD_REF}  (use this for checkout)"
        echo "SHA:          ${BD_SHA}"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "Next steps:"
        echo "  1. Checkout: actions/checkout with ref: \${TF_BD_REF}"
        echo "  2. Configure cloud credentials using TF_BD_ENVIRONMENT"
        echo "  3. Run execute mode"

    # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
    # â•‘                           EXECUTE MODE                                    â•‘
    # â•‘   Validate state â†’ Hooks â†’ Terraform â†’ Lifecycle completion              â•‘
    # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    - name: "[Execute] Validate State"
      if: inputs.mode == 'execute'
      shell: bash
      run: |
        ERROR_COUNT=0
        
        if [[ -z "${TF_BD_ENVIRONMENT}" ]]; then
          echo "::error::TF_BD_ENVIRONMENT is not set"
          ERROR_COUNT=$((ERROR_COUNT + 1))
        fi
        
        if [[ -z "${TF_BD_OPERATION}" ]]; then
          echo "::error::TF_BD_OPERATION is not set"
          ERROR_COUNT=$((ERROR_COUNT + 1))
        fi
        
        if [[ -z "${TF_BD_SHA}" ]]; then
          echo "::error::TF_BD_SHA is not set"
          ERROR_COUNT=$((ERROR_COUNT + 1))
        fi
        
        if [[ $ERROR_COUNT -gt 0 ]]; then
          echo ""
          echo "::error::Did you run mode: trigger first?"
          echo "::error::Execute mode requires TF_BD_* environment variables from trigger mode."
          exit 1
        fi
        
        echo "âœ… State validated: ${TF_BD_ENVIRONMENT} / ${TF_BD_OPERATION}"

    - name: "[Execute] Cache Plan File"
      uses: actions/cache@v5
      if: inputs.mode == 'execute'
      with:
        path: |
          **/*.tfplan
        key: tfplan-${{ env.TF_BD_ENVIRONMENT }}-${{ env.TF_BD_SHA }}

    - name: "[Execute] Run Terraform"
      id: tf-execute
      if: inputs.mode == 'execute'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        TF_BD_EXTRA_ARGS: ${{ env.TF_BD_PARAMS }}
      run: |
        if ! command -v tf-branch-deploy &> /dev/null; then
          echo "::error::tf-branch-deploy command not found"
          exit 1
        fi
        
        DRY_RUN_FLAG=""
        if [ "${{ inputs.dry-run }}" == "true" ]; then
          DRY_RUN_FLAG="--dry-run"
        fi
        
        if [ -n "$TF_BD_EXTRA_ARGS" ]; then
          echo "ðŸ“ Extra terraform args: $TF_BD_EXTRA_ARGS"
        fi
        
        tf-branch-deploy execute \
          --environment "${TF_BD_ENVIRONMENT}" \
          --operation "${TF_BD_OPERATION}" \
          --sha "${TF_BD_SHA}" \
          --config "${{ inputs.config-path }}" \
          $DRY_RUN_FLAG

    - name: "[Execute] Complete Deployment Lifecycle"
      if: inputs.mode == 'execute' && always()
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        GH_REPO: ${{ github.repository }}
        TF_BD_INITIAL_REACTION_ID: ${{ env.TF_BD_INITIAL_REACTION_ID }}
        TF_BD_DEPLOYMENT_ID: ${{ env.TF_BD_DEPLOYMENT_ID }}
        STATUS: ${{ steps.execute.outcome }}
        FAILURE_REASON: ${{ steps.execute.outputs.failure_reason }}
        FAILURE_TITLE: ${{ steps.execute.outputs.failure_title }}
      run: |
        # Determine success/failure from previous step
        if [[ "${{ env.STATUS }}" == "success" ]]; then
          STATUS="success"
          REACTION="rocket"
          echo "âœ… Execution succeeded"
        else
          STATUS="failure"
          REACTION="-1"
          echo "âŒ Execution failed"
        fi
        
        echo ""
        echo "ðŸ”„ Completing lifecycle..."
        
        # 1. Update deployment status (only if deployment was created)
        if [[ -n "${TF_BD_DEPLOYMENT_ID}" ]]; then
          echo "   ðŸ“Š Updating deployment status to: ${STATUS}"
          gh api --method POST \
            "repos/${GH_REPO}/deployments/${TF_BD_DEPLOYMENT_ID}/statuses" \
            -f state="${STATUS}" \
            -f environment="${TF_BD_ENVIRONMENT}" \
            > /dev/null 2>&1 || echo "   âš ï¸  Failed to update deployment status"
        fi
        
        # 2. Remove initial reaction
        if [[ -n "${TF_BD_INITIAL_REACTION_ID}" && -n "${TF_BD_COMMENT_ID}" ]]; then
          echo "   ðŸ—‘ï¸  Removing initial reaction"
          gh api --method DELETE \
            "repos/${GH_REPO}/issues/comments/${TF_BD_COMMENT_ID}/reactions/${TF_BD_INITIAL_REACTION_ID}" \
            > /dev/null 2>&1 || true
        fi
        
        # 3. Add result reaction
        if [[ -n "${TF_BD_COMMENT_ID}" ]]; then
          echo "   âœ¨ Adding ${REACTION} reaction"
          gh api --method POST \
            "repos/${GH_REPO}/issues/comments/${TF_BD_COMMENT_ID}/reactions" \
            -f content="${REACTION}" \
            > /dev/null 2>&1 || echo "   âš ï¸  Failed to add reaction"
        fi
        
          # 4. Post result comment (for both noop and apply operations)
          if [[ -n "${TF_BD_PR_NUMBER}" ]]; then
            echo "   ðŸ’¬ Posting deployment result comment"
            
            if [[ "${TF_BD_NOOP}" == "true" ]]; then
              DEPLOY_TYPE="**noop** deployed"
            else
              DEPLOY_TYPE="deployed"
            fi
            
            if [[ "${STATUS}" == "success" ]]; then
              RESULT_HEADER="### Deployment Results âœ…"
              RESULT_MSG="**${TF_BD_ACTOR}** successfully ${DEPLOY_TYPE} branch \`${TF_BD_REF}\` to **${TF_BD_ENVIRONMENT}**"
            else
              # FAILURE HANDLING V3
              if [[ -n "${FAILURE_TITLE}" ]]; then
                  # Professional Error format: Title + Reason
                  RESULT_HEADER="### âš ï¸ ${FAILURE_TITLE}"
                  RESULT_MSG="${FAILURE_REASON}"
              else
                  # Fallback for unexpected failures
                  RESULT_HEADER="### Deployment Results âŒ"
                  RESULT_MSG="**${TF_BD_ACTOR}** had a failure when deploying branch \`${TF_BD_REF}\` to **${TF_BD_ENVIRONMENT}**"
                  
                  if [[ -n "${FAILURE_REASON}" ]]; then
                     FORMATTED_REASON=$(echo "${FAILURE_REASON}" | sed 's/^/> /')
                     RESULT_MSG="${RESULT_MSG}"$'\n\n'"> [!CAUTION]"$'\n'"${FORMATTED_REASON}"
                  fi
              fi
            fi
            
            # Construct metadata JSON safely using jq
          METADATA=$(jq -n \
            --arg type "${TF_BD_TYPE}" \
            --arg env "${TF_BD_ENVIRONMENT}" \
            --arg ref "${TF_BD_REF}" \
            --arg sha "${TF_BD_SHA}" \
            --arg actor "${TF_BD_ACTOR}" \
            --arg noop "${TF_BD_NOOP}" \
            --arg deployment_id "${TF_BD_DEPLOYMENT_ID}" \
            '{
              type: $type,
              environment: { name: $env },
              deployment: { id: $deployment_id },
              git: { ref: $ref, commit: $sha },
              context: { actor: $actor, noop: ($noop == "true") }
            }'
          )
          
          BODY="${RESULT_HEADER}"$'\n\n'"${RESULT_MSG}"$'\n\n'"<details><summary>Details</summary>"$'\n\n'"\`\`\`json"$'\n'"${METADATA}"$'\n'"\`\`\`"$'\n\n'"</details>"
          
          gh api --method POST \
            "repos/${GH_REPO}/issues/${TF_BD_PR_NUMBER}/comments" \
            -f body="${BODY}" \
            > /dev/null 2>&1 || echo "   âš ï¸  Failed to post result comment"
        fi
        
        # 5. Remove non-sticky lock
        LOCK_REF="${TF_BD_ENVIRONMENT}-branch-deploy-lock"
        echo "   ðŸ”“ Checking for non-sticky lock"
        LOCK_DATA=$(gh api "repos/${GH_REPO}/contents/lock.json?ref=${LOCK_REF}" --jq '.content' 2>/dev/null | base64 -d 2>/dev/null || echo '{}')
        STICKY=$(echo "${LOCK_DATA}" | jq -r '.sticky // "false"' 2>/dev/null || echo "false")
        
        if [[ "${STICKY}" != "true" ]]; then
          echo "   ðŸ—‘ï¸  Removing non-sticky lock"
          gh api --method DELETE "repos/${GH_REPO}/git/refs/heads/${LOCK_REF}" 2>/dev/null || true
        else
          echo "   ðŸ”’ Lock is sticky - preserving"
        fi
        
        echo ""
        echo "âœ… Lifecycle complete"

