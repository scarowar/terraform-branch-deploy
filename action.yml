name: terraform-branch-deploy
description: ChatOps for Terraform deployments via GitHub PRs - perfect integration with branch-deploy

author: Sourab Kanthavar <@scarowar>

branding:
  icon: git-pull-request
  color: purple

inputs:
  # === MODE SELECTION ===
  mode:
    description: |
      dispatch = Parse command via branch-deploy + run terraform (default, one-step)
      execute = Run terraform only (use after your own branch-deploy call)
    default: "dispatch"

  # === TF-BRANCH-DEPLOY SPECIFIC ===
  github-token:
    description: "GitHub token with pull-requests:write, deployments:write, contents:write"
    required: true
  config-path:
    description: "Path to .tf-branch-deploy.yml"
    default: ".tf-branch-deploy.yml"
  terraform-version:
    description: "Terraform version to install"
    default: "latest"

  # === FOR EXECUTE MODE (passed from your branch-deploy call) ===
  environment:
    description: "[execute mode] Target environment from branch-deploy outputs"
    default: ""
  operation:
    description: "[execute mode] plan or apply"
    default: ""
  sha:
    description: "[execute mode] Commit SHA from branch-deploy outputs"
    default: ""
  deployment-id:
    description: "[execute mode] Deployment ID from branch-deploy (for status updates)"
    default: ""
  pr-number:
    description: "[execute mode] PR number for comments"
    default: ""
  dry-run:
    description: "Print commands without running"
    default: "false"
  pre-terraform-hook:
    description: |
      Shell commands to run AFTER branch-deploy but BEFORE terraform.
      Use this for: building lambdas, fetching secrets, running migrations.
      Environment variables available: TF_BD_ENVIRONMENT, TF_BD_SHA, TF_BD_OPERATION
    default: ""
  is-rollback:
    description: "[execute mode] Set to 'true' for rollback - allows apply without plan"
    default: "false"
  extra-args:
    description: "[execute mode] Extra terraform args"
    default: ""

  # === BRANCH-DEPLOY PASSTHROUGH (dispatch mode only) ===
  trigger:
    description: "Deploy command trigger"
    default: ".apply"
  noop-trigger:
    description: "Plan command trigger"
    default: ".plan"
  lock-trigger:
    description: "Lock command trigger"
    default: ".lock"
  unlock-trigger:
    description: "Unlock command trigger"
    default: ".unlock"
  help-trigger:
    description: "Help command trigger"
    default: ".help"
  lock-info-alias:
    description: "Lock info alias"
    default: ".wcid"
  param-separator:
    description: "Parameter separator in commands"
    default: "|"
  environment-targets:
    description: "Comma-separated environments (auto-detected from config if empty)"
    default: ""
  production-environments:
    description: "Comma-separated production environments"
    default: ""
  environment-urls:
    description: "Environment URLs mapping"
    default: ""
  draft-permitted-targets:
    description: "Environments allowing draft PR deployments"
    default: ""
  stable-branch:
    description: "Stable branch for rollbacks"
    default: "main"
  update-branch:
    description: "How to handle outdated branches: disabled|warn|force"
    default: "warn"
  outdated-mode:
    description: "Branch freshness check: strict|pr_base|default_branch"
    default: "strict"
  allow-sha-deployments:
    description: "Allow deploying specific SHAs"
    default: "false"
  enforced-deployment-order:
    description: "Required deployment order (e.g., dev,staging,prod)"
    default: ""
  checks:
    description: "CI check requirements: all|required|<check-names>"
    default: "all"
  ignored-checks:
    description: "Checks to ignore"
    default: ""
  skip-ci:
    description: "Environments that skip CI"
    default: ""
  skip-reviews:
    description: "Environments that skip reviews"
    default: ""
  required-contexts:
    description: "Manually required status contexts"
    default: "false"
  permissions:
    description: "Required GitHub permissions"
    default: "write,admin"
  admins:
    description: "Admin users/teams"
    default: "false"
  admins-pat:
    description: "PAT for admin team lookups"
    default: "false"
  commit-verification:
    description: "Require verified commits"
    default: "false"
  disable-naked-commands:
    description: "Require environment in commands"
    default: "true"
  allow-forks:
    description: "Allow fork deployments"
    default: "true"
  allow-non-default-target-branch:
    description: "Allow non-default target branch deployments"
    default: "false"
  deployment-confirmation:
    description: "Require deployment confirmation"
    default: "false"
  deployment-confirmation-timeout:
    description: "Confirmation timeout in seconds"
    default: "60"
  global-lock-flag:
    description: "Global lock flag"
    default: "--global"
  sticky-locks:
    description: "Keep locks after deployment"
    default: "false"
  sticky-locks-for-noop:
    description: "Keep locks for plan operations"
    default: "false"
  successful-deploy-labels:
    description: "Labels for successful deploy"
    default: ""
  successful-noop-labels:
    description: "Labels for successful plan"
    default: ""
  failed-deploy-labels:
    description: "Labels for failed deploy"
    default: ""
  failed-noop-labels:
    description: "Labels for failed plan"
    default: ""
  skip-successful-noop-labels-if-approved:
    description: "Skip noop labels if PR is approved"
    default: "false"
  skip-successful-deploy-labels-if-approved:
    description: "Skip deploy labels if PR is approved"
    default: "false"
  use-security-warnings:
    description: "Show security warnings in logs"
    default: "true"
  merge-deploy-mode:
    description: "Enable merge deploy mode"
    default: "false"
  unlock-on-merge-mode:
    description: "Unlock environments on PR merge"
    default: "false"
  environment-url-in-comment:
    description: "Append environment URL to success comment"
    default: "true"
  deploy-message-path:
    description: "Custom deployment message template"
    default: ".github/deployment_message.md"
  reaction:
    description: "Reaction emoji for trigger detection"
    default: "eyes"

outputs:
  # From branch-deploy (dispatch mode)
  continue:
    description: "'true' if deployment should proceed"
    value: ${{ steps.branch-deploy.outputs.continue }}
  triggered:
    description: "'true' if command was detected"
    value: ${{ steps.branch-deploy.outputs.triggered }}
  environment:
    description: "Target environment"
    value: ${{ steps.branch-deploy.outputs.environment }}
  sha:
    description: "Commit SHA to deploy"
    value: ${{ steps.branch-deploy.outputs.sha }}
  ref:
    description: "Branch ref to deploy"
    value: ${{ steps.branch-deploy.outputs.ref }}
  noop:
    description: "'true' for plan operations"
    value: ${{ steps.branch-deploy.outputs.noop }}
  actor:
    description: "User who triggered deployment"
    value: ${{ steps.branch-deploy.outputs.actor }}
  params:
    description: "Raw parameters from command"
    value: ${{ steps.branch-deploy.outputs.params }}
  comment-id:
    description: "Triggering comment ID"
    value: ${{ steps.branch-deploy.outputs.comment_id }}
  deployment-id:
    description: "GitHub deployment ID"
    value: ${{ steps.branch-deploy.outputs.deployment_id }}
  type:
    description: "Command type (deploy, lock, unlock, etc.)"
    value: ${{ steps.branch-deploy.outputs.type }}
  issue-number:
    description: "PR/Issue number"
    value: ${{ steps.branch-deploy.outputs.issue_number }}

  # Terraform-specific
  working-directory:
    description: "Terraform working directory"
    value: ${{ steps.tf-execute.outputs.working_directory }}
  var-files:
    description: "JSON array of var files"
    value: ${{ steps.tf-execute.outputs.var_files }}
  is-production:
    description: "'true' if production environment"
    value: ${{ steps.tf-execute.outputs.is_production }}
  plan-file:
    description: "Path to plan file (after plan)"
    value: ${{ steps.tf-execute.outputs.plan_file }}
  plan-checksum:
    description: "SHA256 of plan file"
    value: ${{ steps.tf-execute.outputs.plan_checksum }}
  has-changes:
    description: "'true' if plan has changes"
    value: ${{ steps.tf-execute.outputs.has_changes }}

runs:
  using: composite
  steps:
    # === SETUP (both modes) ===
    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: "3.12"

    - name: Setup UV
      uses: astral-sh/setup-uv@v5

    - name: Install tf-branch-deploy
      shell: bash
      run: uv pip install --system "${{ github.action_path }}"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ inputs.terraform-version }}
        terraform_wrapper: false

    - name: Setup tfcmt
      shell: bash
      run: |
        TFCMT_VERSION="v4.14.0"
        curl -fsSL "https://github.com/suzuki-shunsuke/tfcmt/releases/download/${TFCMT_VERSION}/tfcmt_linux_amd64.tar.gz" | tar xz -C /usr/local/bin tfcmt
        chmod +x /usr/local/bin/tfcmt
        tfcmt --version

    # === DISPATCH MODE: Run branch-deploy + terraform ===
    - name: Detect environments from config
      id: detect-envs
      if: inputs.mode == 'dispatch'
      shell: bash
      run: |
        if [ -n "${{ inputs.environment-targets }}" ]; then
          echo "targets=${{ inputs.environment-targets }}" >> $GITHUB_OUTPUT
          echo "default=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          echo "production=${{ inputs.production-environments }}" >> $GITHUB_OUTPUT
        else
          config_path="${{ inputs.config-path }}"
          if [ -f "$config_path" ]; then
            targets=$(tf-branch-deploy environments --config "$config_path" 2>/dev/null || echo "production")
            default=$(yq -r '.["default-environment"] // "production"' "$config_path" 2>/dev/null || echo "production")
            production=$(yq -r '.["production-environments"] | join(",")' "$config_path" 2>/dev/null || echo "production")
          else
            targets="production"
            default="production"
            production="production"
          fi
          echo "targets=$targets" >> $GITHUB_OUTPUT
          echo "default=$default" >> $GITHUB_OUTPUT
          echo "production=$production" >> $GITHUB_OUTPUT
        fi

    - name: IssueOps Command Dispatcher
      id: branch-deploy
      if: inputs.mode == 'dispatch'
      uses: github/branch-deploy@v11
      with:
        github_token: ${{ inputs.github-token }}
        trigger: ${{ inputs.trigger }}
        noop_trigger: ${{ inputs.noop-trigger }}
        lock_trigger: ${{ inputs.lock-trigger }}
        unlock_trigger: ${{ inputs.unlock-trigger }}
        help_trigger: ${{ inputs.help-trigger }}
        lock_info_alias: ${{ inputs.lock-info-alias }}
        param_separator: ${{ inputs.param-separator }}
        environment: ${{ steps.detect-envs.outputs.default }}
        environment_targets: ${{ steps.detect-envs.outputs.targets }}
        production_environments: ${{ steps.detect-envs.outputs.production }}
        environment_urls: ${{ inputs.environment-urls }}
        draft_permitted_targets: ${{ inputs.draft-permitted-targets }}
        stable_branch: ${{ inputs.stable-branch }}
        update_branch: ${{ inputs.update-branch }}
        outdated_mode: ${{ inputs.outdated-mode }}
        allow_sha_deployments: ${{ inputs.allow-sha-deployments }}
        enforced_deployment_order: ${{ inputs.enforced-deployment-order }}
        checks: ${{ inputs.checks }}
        ignored_checks: ${{ inputs.ignored-checks }}
        skip_ci: ${{ inputs.skip-ci }}
        skip_reviews: ${{ inputs.skip-reviews }}
        required_contexts: ${{ inputs.required-contexts }}
        permissions: ${{ inputs.permissions }}
        admins: ${{ inputs.admins }}
        admins_pat: ${{ inputs.admins-pat }}
        commit_verification: ${{ inputs.commit-verification }}
        disable_naked_commands: ${{ inputs.disable-naked-commands }}
        allow_forks: ${{ inputs.allow-forks }}
        allow_non_default_target_branch_deployments: ${{ inputs.allow-non-default-target-branch }}
        deployment_confirmation: ${{ inputs.deployment-confirmation }}
        deployment_confirmation_timeout: ${{ inputs.deployment-confirmation-timeout }}
        global_lock_flag: ${{ inputs.global-lock-flag }}
        sticky_locks: ${{ inputs.sticky-locks }}
        sticky_locks_for_noop: ${{ inputs.sticky-locks-for-noop }}
        successful_deploy_labels: ${{ inputs.successful-deploy-labels }}
        successful_noop_labels: ${{ inputs.successful-noop-labels }}
        failed_deploy_labels: ${{ inputs.failed-deploy-labels }}
        failed_noop_labels: ${{ inputs.failed-noop-labels }}
        skip_successful_noop_labels_if_approved: ${{ inputs.skip-successful-noop-labels-if-approved }}
        skip_successful_deploy_labels_if_approved: ${{ inputs.skip-successful-deploy-labels-if-approved }}
        use_security_warnings: ${{ inputs.use-security-warnings }}
        merge_deploy_mode: ${{ inputs.merge-deploy-mode }}
        unlock_on_merge_mode: ${{ inputs.unlock-on-merge-mode }}
        environment_url_in_comment: ${{ inputs.environment-url-in-comment }}
        deploy_message_path: ${{ inputs.deploy-message-path }}
        reaction: ${{ inputs.reaction }}
        # NOTE: We do NOT set skip_completing - branch-deploy handles cleanup automatically
        # This means branch-deploy will: update deployment status, remove locks, add reactions, post comments

    # === PERSISTENCE: Cache Plan Files ===
    # This allows the 'Apply' run to find the plan generated by the 'Plan' run
    # Runs AFTER branch-deploy so we have the environment/sha outputs available
    - name: Cache Plan File
      uses: actions/cache@v4
      if: |
        (inputs.mode == 'dispatch' && steps.branch-deploy.outputs.continue == 'true') ||
        (inputs.mode == 'execute')
      with:
        path: |
          **/*.tfplan
        # Key format: tfplan-{env}-{sha}
        key: tfplan-${{ inputs.mode == 'dispatch' && steps.branch-deploy.outputs.environment || inputs.environment }}-${{ inputs.mode == 'dispatch' && steps.branch-deploy.outputs.sha || inputs.sha }}

    # === PRE-TERRAFORM HOOK (for prep work like building lambdas, fetching secrets) ===
    - name: Run Pre-Terraform Hook
      id: pre-hook
      if: |
        inputs.pre-terraform-hook != '' &&
        ((inputs.mode == 'dispatch' && steps.branch-deploy.outputs.continue == 'true') ||
         (inputs.mode == 'execute'))
      shell: bash
      env:
        TF_BD_ENVIRONMENT: ${{ inputs.mode == 'dispatch' && steps.branch-deploy.outputs.environment || inputs.environment }}
        TF_BD_SHA: ${{ inputs.mode == 'dispatch' && steps.branch-deploy.outputs.sha || inputs.sha }}
        TF_BD_OPERATION: ${{ inputs.mode == 'dispatch' && (steps.branch-deploy.outputs.noop == 'true' && 'plan' || 'apply') || inputs.operation }}
        TF_BD_IS_NOOP: ${{ inputs.mode == 'dispatch' && steps.branch-deploy.outputs.noop || 'false' }}
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        echo "üîß Running pre-terraform hook for environment: $TF_BD_ENVIRONMENT"
        ${{ inputs.pre-terraform-hook }}

    # === EXECUTE TERRAFORM ===
    - name: Execute Terraform
      id: tf-execute
      if: |
        (inputs.mode == 'dispatch' && steps.branch-deploy.outputs.continue == 'true') ||
        (inputs.mode == 'execute')
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
        TF_BD_PR_NUMBER: ${{ inputs.mode == 'dispatch' && steps.branch-deploy.outputs.issue_number || inputs.pr-number }}
        # Rollback detection: .apply main to dev (ref is stable branch, not PR branch)
        TF_BD_IS_ROLLBACK: ${{ inputs.mode == 'dispatch' && steps.branch-deploy.outputs.ref == inputs.stable-branch || inputs.is-rollback }}
      run: |
        # Determine values based on mode
        if [ "${{ inputs.mode }}" == "dispatch" ]; then
          ENV="${{ steps.branch-deploy.outputs.environment }}"
          SHA="${{ steps.branch-deploy.outputs.sha }}"
          OPERATION="${{ steps.branch-deploy.outputs.noop == 'true' && 'plan' || 'apply' }}"
          # Params from PR comment (e.g., ".plan to dev | --target=module.base")
          PARAMS="${{ steps.branch-deploy.outputs.params }}"
        else
          ENV="${{ inputs.environment }}"
          SHA="${{ inputs.sha }}"
          OPERATION="${{ inputs.operation }}"
          PARAMS="${{ inputs.extra-args }}"
        fi

        DRY_RUN_FLAG=""
        if [ "${{ inputs.dry-run }}" == "true" ]; then
          DRY_RUN_FLAG="--dry-run"
        fi

        # Build extra args from params
        EXTRA_ARGS=""
        if [ -n "$PARAMS" ]; then
          echo "üìù Extra terraform args from command: $PARAMS"
          EXTRA_ARGS="--extra-args \"$PARAMS\""
        fi

        tf-branch-deploy execute \
          --environment "$ENV" \
          --operation "$OPERATION" \
          --sha "$SHA" \
          --config "${{ inputs.config-path }}" \
          $DRY_RUN_FLAG \
          $EXTRA_ARGS
